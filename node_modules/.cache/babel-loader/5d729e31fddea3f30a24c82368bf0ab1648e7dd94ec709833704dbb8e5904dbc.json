{"ast":null,"code":"import shortid from \"shortid\";\nimport { COLUMN, COMPONENT, ROW } from \"./constants\";\n\n// a little function to help us with reordering the result\nexport const reorder = (list, startIndex, endIndex) => {\n  const result = Array.from(list);\n  console.log('reorder', result, startIndex, endIndex);\n  const [removed] = result.splice(startIndex, 1);\n  if (startIndex < endIndex && endIndex > 0) {\n    endIndex = endIndex - 1;\n  }\n  result.splice(endIndex, 0, removed); // inserting task in new index\n\n  return result;\n};\nexport const remove = (arr, index) => [\n// part of the array before the specified index\n...arr.slice(0, index),\n// part of the array after the specified index\n...arr.slice(index + 1)];\nexport const insert = (arr, index, newItem) => [\n// part of the array before the specified index\n...arr.slice(0, index),\n// inserted item\nnewItem,\n// part of the array after the specified index\n...arr.slice(index)];\nexport const reorderChildren = (children, splitDropZonePath, splitItemPath) => {\n  console.log('reorderChildren');\n  if (splitDropZonePath.length === 1) {\n    const dropZoneIndex = Number(splitDropZonePath[0]);\n    const itemIndex = Number(splitItemPath[0]);\n    console.log(dropZoneIndex, \"dropZoneIndex\", itemIndex, \"itemIndex\");\n    return reorder(children, itemIndex, dropZoneIndex);\n  }\n  const updatedChildren = [...children];\n  const curIndex = Number(splitDropZonePath.slice(0, 1));\n\n  // Update the specific node's children\n  const splitDropZoneChildrenPath = splitDropZonePath.slice(1);\n  const splitItemChildrenPath = splitItemPath.slice(1);\n  const nodeChildren = updatedChildren[curIndex];\n  updatedChildren[curIndex] = {\n    ...nodeChildren,\n    children: reorderChildren(nodeChildren.children, splitDropZoneChildrenPath, splitItemChildrenPath)\n  };\n  return updatedChildren;\n};\nexport const removeChildFromChildren = (children, splitItemPath) => {\n  if (splitItemPath.length === 1) {\n    const itemIndex = Number(splitItemPath[0]);\n    return remove(children, itemIndex);\n  }\n  const updatedChildren = [...children];\n  const curIndex = Number(splitItemPath.slice(0, 1));\n\n  // Update the specific node's children\n  const splitItemChildrenPath = splitItemPath.slice(1);\n  const nodeChildren = updatedChildren[curIndex];\n  updatedChildren[curIndex] = {\n    ...nodeChildren,\n    children: removeChildFromChildren(nodeChildren.children, splitItemChildrenPath)\n  };\n  return updatedChildren;\n};\nexport const addChildToChildren = (children, splitDropZonePath, item) => {\n  if (splitDropZonePath.length === 1) {\n    const dropZoneIndex = Number(splitDropZonePath[0]);\n    return insert(children, dropZoneIndex, item);\n  }\n  const updatedChildren = [...children];\n  const curIndex = Number(splitDropZonePath.slice(0, 1));\n\n  // Update the specific node's children\n  const splitItemChildrenPath = splitDropZonePath.slice(1);\n  const nodeChildren = updatedChildren[curIndex];\n  updatedChildren[curIndex] = {\n    ...nodeChildren,\n    children: addChildToChildren(nodeChildren.children, splitItemChildrenPath, item)\n  };\n  return updatedChildren;\n};\nexport const handleMoveWithinParent = (layout, splitDropZonePath, splitItemPath) => {\n  return reorderChildren(layout, splitDropZonePath, splitItemPath);\n};\nexport const handleAddColumDataToRow = layout => {\n  const layoutCopy = [...layout];\n  const COLUMN_STRUCTURE = {\n    type: COLUMN,\n    id: shortid.generate(),\n    children: []\n  };\n  return layoutCopy.map(row => {\n    if (!row.children.length) {\n      row.children = [COLUMN_STRUCTURE];\n    }\n    return row;\n  });\n};\nexport const handleMoveToDifferentParent = (layout, splitDropZonePath, splitItemPath, item) => {\n  console.log('handleMoveToDifferentParent');\n  let newLayoutStructure;\n  const COLUMN_STRUCTURE = {\n    type: COLUMN,\n    id: shortid.generate(),\n    children: [item]\n  };\n  const ROW_STRUCTURE = {\n    type: ROW,\n    id: shortid.generate()\n  };\n  switch (splitDropZonePath.length) {\n    case 1:\n      {\n        // moving column outside into new row made on the fly\n        if (item.type === COLUMN) {\n          newLayoutStructure = {\n            ...ROW_STRUCTURE,\n            children: [item]\n          };\n        } else {\n          // moving component outside into new row made on the fly\n          newLayoutStructure = {\n            ...ROW_STRUCTURE,\n            children: [COLUMN_STRUCTURE]\n          };\n        }\n        break;\n      }\n    case 2:\n      {\n        // moving component outside into a row which creates column\n        if (item.type === COMPONENT) {\n          newLayoutStructure = COLUMN_STRUCTURE;\n        } else {\n          // moving column into existing row\n          newLayoutStructure = item;\n        }\n        break;\n      }\n    default:\n      {\n        newLayoutStructure = item;\n      }\n  }\n  let updatedLayout = layout;\n  updatedLayout = removeChildFromChildren(updatedLayout, splitItemPath);\n  updatedLayout = handleAddColumDataToRow(updatedLayout);\n  updatedLayout = addChildToChildren(updatedLayout, splitDropZonePath, newLayoutStructure);\n  return updatedLayout;\n};\nexport const handleMoveSidebarComponentIntoParent = (layout, splitDropZonePath, item) => {\n  console.log('handleMoveSidebarComponentIntoParent');\n  console.log(layout, splitDropZonePath, item, \"layout,splitDropZonePath,item\");\n  let newLayoutStructure;\n  switch (splitDropZonePath.length) {\n    case 1:\n      {\n        if (item.type === ROW) {\n          newLayoutStructure = {\n            type: ROW,\n            id: shortid.generate(),\n            children: []\n          };\n        } else if (item.type === COLUMN) {\n          newLayoutStructure = {\n            type: ROW,\n            id: shortid.generate(),\n            children: [{\n              type: COLUMN,\n              id: shortid.generate(),\n              children: []\n            }]\n          };\n        } else {\n          newLayoutStructure = {\n            type: ROW,\n            id: shortid.generate(),\n            children: [{\n              type: COLUMN,\n              id: shortid.generate(),\n              children: [item]\n            }]\n          };\n        }\n        break;\n      }\n    case 2:\n      {\n        if (item.type === ROW) {\n          return layout;\n        } else if (item.type === COLUMN) {\n          newLayoutStructure = {\n            type: COLUMN,\n            id: shortid.generate(),\n            children: []\n          };\n        } else {\n          newLayoutStructure = {\n            type: COLUMN,\n            id: shortid.generate(),\n            children: [item]\n          };\n        }\n        break;\n      }\n    default:\n      {\n        if (item.type === ROW || item.type === COLUMN) {\n          return layout;\n        }\n        newLayoutStructure = item;\n      }\n  }\n  return addChildToChildren(layout, splitDropZonePath, newLayoutStructure);\n};\nexport const handleRemoveItemFromLayout = (layout, splitItemPath) => {\n  return removeChildFromChildren(layout, splitItemPath);\n};","map":{"version":3,"names":["shortid","COLUMN","COMPONENT","ROW","reorder","list","startIndex","endIndex","result","Array","from","console","log","removed","splice","remove","arr","index","slice","insert","newItem","reorderChildren","children","splitDropZonePath","splitItemPath","length","dropZoneIndex","Number","itemIndex","updatedChildren","curIndex","splitDropZoneChildrenPath","splitItemChildrenPath","nodeChildren","removeChildFromChildren","addChildToChildren","item","handleMoveWithinParent","layout","handleAddColumDataToRow","layoutCopy","COLUMN_STRUCTURE","type","id","generate","map","row","handleMoveToDifferentParent","newLayoutStructure","ROW_STRUCTURE","updatedLayout","handleMoveSidebarComponentIntoParent","handleRemoveItemFromLayout"],"sources":["/home/arm/Desktop/exp/dnd-two/src/helpers.js"],"sourcesContent":["import shortid from \"shortid\";\nimport { COLUMN, COMPONENT, ROW } from \"./constants\";\n\n// a little function to help us with reordering the result\nexport const reorder = (list, startIndex, endIndex) => {\n \n  const result = Array.from(list);\n  console.log('reorder',result,startIndex, endIndex);\n  const [removed] = result.splice(startIndex, 1);\n\nif(startIndex<endIndex&&endIndex>0){\n  endIndex=endIndex-1;\n}\n  result.splice(endIndex, 0, removed); // inserting task in new index\n\n  return result;\n};\n\nexport const remove = (arr, index) => [\n  // part of the array before the specified index\n  ...arr.slice(0, index),\n  // part of the array after the specified index\n  ...arr.slice(index + 1)\n];\n\nexport const insert = (arr, index, newItem) => [\n  // part of the array before the specified index\n  ...arr.slice(0, index),\n  // inserted item\n  newItem,\n  // part of the array after the specified index\n  ...arr.slice(index)\n];\n\nexport const reorderChildren = (children, splitDropZonePath, splitItemPath) => {\n  console.log('reorderChildren');\n  if (splitDropZonePath.length === 1) {\n    const dropZoneIndex = Number(splitDropZonePath[0]);\n    const itemIndex = Number(splitItemPath[0]);\n    console.log(dropZoneIndex,\"dropZoneIndex\",itemIndex,\"itemIndex\");\n    return reorder(children, itemIndex, dropZoneIndex);\n  }\n\n  const updatedChildren = [...children];\n\n  const curIndex = Number(splitDropZonePath.slice(0, 1));\n\n  // Update the specific node's children\n  const splitDropZoneChildrenPath = splitDropZonePath.slice(1);\n  const splitItemChildrenPath = splitItemPath.slice(1);\n  const nodeChildren = updatedChildren[curIndex];\n  updatedChildren[curIndex] = {\n    ...nodeChildren,\n    children: reorderChildren(\n      nodeChildren.children,\n      splitDropZoneChildrenPath,\n      splitItemChildrenPath\n    )\n  };\n\n  return updatedChildren;\n};\n\nexport const removeChildFromChildren = (children, splitItemPath) => {\n  if (splitItemPath.length === 1) {\n    const itemIndex = Number(splitItemPath[0]);\n    return remove(children, itemIndex);\n  }\n\n  const updatedChildren = [...children];\n\n  const curIndex = Number(splitItemPath.slice(0, 1));\n\n  // Update the specific node's children\n  const splitItemChildrenPath = splitItemPath.slice(1);\n  const nodeChildren = updatedChildren[curIndex];\n  updatedChildren[curIndex] = {\n    ...nodeChildren,\n    children: removeChildFromChildren(\n      nodeChildren.children,\n      splitItemChildrenPath\n    )\n  };\n\n  return updatedChildren;\n};\n\nexport const addChildToChildren = (children, splitDropZonePath, item) => {\n  if (splitDropZonePath.length === 1) {\n    const dropZoneIndex = Number(splitDropZonePath[0]);\n    return insert(children, dropZoneIndex, item);\n  }\n\n  const updatedChildren = [...children];\n\n  const curIndex = Number(splitDropZonePath.slice(0, 1));\n\n  // Update the specific node's children\n  const splitItemChildrenPath = splitDropZonePath.slice(1);\n  const nodeChildren = updatedChildren[curIndex];\n  updatedChildren[curIndex] = {\n    ...nodeChildren,\n    children: addChildToChildren(\n      nodeChildren.children,\n      splitItemChildrenPath,\n      item\n    )\n  };\n\n  return updatedChildren;\n};\n\nexport const handleMoveWithinParent = (\n  layout,\n  splitDropZonePath,\n  splitItemPath\n) => {\n  return reorderChildren(layout, splitDropZonePath, splitItemPath);\n};\n\nexport const handleAddColumDataToRow = layout => {\n  const layoutCopy = [...layout];\n  const COLUMN_STRUCTURE = {\n    type: COLUMN,\n    id: shortid.generate(),\n    children: []\n  };\n\n  return layoutCopy.map(row => {\n    if (!row.children.length) {\n      row.children = [COLUMN_STRUCTURE];\n    }\n    return row;\n  });\n};\n\nexport const handleMoveToDifferentParent = (\n  layout,\n  splitDropZonePath,\n  splitItemPath,\n  item\n) => {\n  console.log('handleMoveToDifferentParent');\n  let newLayoutStructure;\n  const COLUMN_STRUCTURE = {\n    type: COLUMN,\n    id: shortid.generate(),\n    children: [item]\n  };\n\n  const ROW_STRUCTURE = {\n    type: ROW,\n    id: shortid.generate()\n  };\n\n  switch (splitDropZonePath.length) {\n    case 1: {\n      // moving column outside into new row made on the fly\n      if (item.type === COLUMN) {\n        newLayoutStructure = {\n          ...ROW_STRUCTURE,\n          children: [item]\n        };\n      } else {\n        // moving component outside into new row made on the fly\n        newLayoutStructure = {\n          ...ROW_STRUCTURE,\n          children: [COLUMN_STRUCTURE]\n        };\n      }\n      break;\n    }\n    case 2: {\n      // moving component outside into a row which creates column\n      if (item.type === COMPONENT) {\n        newLayoutStructure = COLUMN_STRUCTURE;\n      } else {\n        // moving column into existing row\n        newLayoutStructure = item;\n      }\n\n      break;\n    }\n    default: {\n      newLayoutStructure = item;\n    }\n  }\n\n  let updatedLayout = layout;\n  updatedLayout = removeChildFromChildren(updatedLayout, splitItemPath);\n  updatedLayout = handleAddColumDataToRow(updatedLayout);\n  updatedLayout = addChildToChildren(\n    updatedLayout,\n    splitDropZonePath,\n    newLayoutStructure\n  );\n\n  return updatedLayout;\n};\n\nexport const handleMoveSidebarComponentIntoParent = (\n  layout,\n  splitDropZonePath,\n  item\n) => {\nconsole.log('handleMoveSidebarComponentIntoParent');\n  console.log(layout,splitDropZonePath, item,\"layout,splitDropZonePath,item\");\n  let newLayoutStructure;\n  switch (splitDropZonePath.length) {\n    case 1: {\n      if(item.type===ROW){\n        newLayoutStructure = {\n          type: ROW,\n          id: shortid.generate(),\n          children:[]\n        };\n      }else if(item.type===COLUMN){\n        newLayoutStructure = {\n          type: ROW,\n          id: shortid.generate(),\n          children: [{ type: COLUMN, id: shortid.generate(),children:[] }]\n        };\n      }\n      else{\n        newLayoutStructure = {\n          type: ROW,\n          id: shortid.generate(),\n          children: [{ type: COLUMN, id: shortid.generate(),children:[item] }]\n        };\n      }\n\n      break;\n    }\n    case 2: {\n      if(item.type===ROW){\n        return layout;\n      }\n     else if(item.type===COLUMN){\n        newLayoutStructure = {\n          type: COLUMN,\n          id: shortid.generate(),\n          children: []\n        };\n      }\n      else{\n        newLayoutStructure = {\n          type: COLUMN,\n          id: shortid.generate(),\n          children: [item]\n        };\n      }\n      break;\n    }\n    default: {\n      if(item.type===ROW||item.type===COLUMN){\n        return layout;\n      }\n      newLayoutStructure = item;\n    }\n  }\n\n  return addChildToChildren(layout, splitDropZonePath, newLayoutStructure);\n};\n\n\nexport const handleRemoveItemFromLayout = (layout, splitItemPath) => {\n  return removeChildFromChildren(layout, splitItemPath);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}